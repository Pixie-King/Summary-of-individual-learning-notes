# 数据结构复习

[Toc]

## 一、线性结构表——数组

### 1.0 线性表概念

* n个数据元素的有限序列，可空
* 开始节点只有直接后继，终结节点只有直接前驱，其余节点两者都有
* 线性表的顺序存储结构随机存储，不能完整表示树，但可以表示二叉树，因此可以存储线性结构和层次结构

### 1.1 操作

* 访问 时间复杂度O(1)
* 插入 时间复杂度O(N）在第i个位置前插入，应后移n-i+1个元素
* 删除 时间复杂度O(N)   删除第i个元素，应前移n-i个元素
* 等概率情况下，插入节点平均需要移动n/2个元素，删除为（n-1）/2，查找为(n+1)/2，具体取决于表长和位置

## 二、链式线性表——链表

### 2.0 特点

* 密度小
* 删除插入方便，不必移动节点
* 不必事先估计存储空间
* 所需空间与线性表长度成正比

### 2.1 分类

* 是否带头结点
* 单链表与双链表 
* 循环链表

### 2.2 操作

#### 、2.2.1 判断是否为空

* 带头结点的链表：

  ```c++
  if(head->next == NULL)
  ```

* 不带头结点的链表：

  ```c++
  if(head == NULL)
  ```

* 带头结点的循环链表：

  ```c++
  if(head->next == head)
  ```

  

#### 2.2.2 插入节点(操作的次序问题)

* 有序单链表

  方式一：依次读入n个值，按位置插入，插入一个值时间复杂度O(N),插入n个值O(N²)

  方拾二：采用某种排序方法，在数组中排成降序，依次插入表头，排序复杂度O(Nlog<sub>2</sub>N)

  )，全部插入O(N)，总复杂度O(Nlog<sub>2</sub>N).

* 双向循环链表（非尾指针p后插入s）

  ```c++
  s->last = p;
  s->next = p->next;
  p->next->last = s;
  p->next = s;
  ```

#### 2.2.3 删除节点

#### 2.2.4 其他操作

* 翻转

  ```c++
  node reverse(node* head){
  	node * n = head;
  	head = nullptr;
  	while(n){
  	node* m = n;
  	n = n->next;
  	m->next = head;
  	head = m;
  	}
  	return head;
  }
  ```

  

* 找到链表倒数第K个位置的节点

  在前方放置哨兵，哨兵移动到第k个节点，两指针开始一起前移

* 找到中间节点

  前方放置哨兵，哨兵每前移两步，主指针前移一步

* 判断是否有环

  （1）判断p2走一步和走两步后是否会 遇到空指针（表尾）。如果没有遇到，转（2），否则转（4）。

  （2）p2走两步，p1走一步，判断p1和p2是否指向同一节点，如果是，说明有环，否则转（3）

  （3）进入下一次循环

  （4）返回空（不存在环)

* 判断环的起止位置

## 三、栈、队列

### 3.1 入栈、出栈次序

#### 3.1.1 不限/限制连续出栈次数

#### 3.1.2 不限/限制栈的最大长度

#### 3.1.3 出栈序列可能数

n的 卡特兰数**h(n)=C(2n,n)/(n+1)**

推广：不可能的出栈序列可能数： n!-h(n)

### 3.2 应用

#### 3.2.1 中缀表达式、波兰式（前缀）、逆波兰式（后缀）

* 中缀表达式转逆波兰式:从左到右
* 中缀表达式转波兰式：从右到左，结果翻转
* 计算中缀表达式：操作数栈和运算符栈 同时进行
* 计算后缀表达式：
* 计算前缀表达式：

#### 3.2.2 括号匹配

### 3.3 循环队列

#### 3.3.1 判断空、满

CASE1: V[0……m-1]

*（1）队头指针指向队头元素，队尾指针指向队尾元素

* 初始 队头指针在V[0],队尾指针在V[m-1]
* 元素个数：（rear-front+1+m）%m
* 判断为空：(rear+1)%m==front
* 判断为满：(rear+2)%m==front

*（2）队头指针指向队头元素，队尾指针指向队尾元素的后一个

* 初始 队头指针在V[0],队尾指针在V[0]
* 元素个数：（rear-front+m）%m
* 判断为空：rear==front
* 判断为满：(rear+1)%m==front

CASE2: V[m……n]

*队头指针指向队头元素，队尾指针指向队尾元素的后一个

* 初始 队头指针在V[m],队尾指针在V[m]
* 元素个数：（rear-front+n-m+1）%(n-m+1)
* 判断为空：rear==front
* 判断为满：(rear+1-m)%(n-m+1)+m==front

#### 3.3.2 由判断空/满条件推导初始位置

## 四、树

### 4.1 树

* 由各个度的节点数求叶节点数
* 满k叉树
* 表示法

### 4.2 二叉树

* 完全二叉树 ：叶节点 n，度为2节点n-1，度为1节点1或0
* 计算含有n个叶节点的完全二叉树最多\最少有几个节点 最多是满树
* 最小高度是满树

### 4.3 遍历

（1）前中后序相同相反问题

* 前序和中序相反 说明若二叉树不为空，任一节点没有右孩子
* 前序和后序相反 说明二叉树高度等于节点数
*  前序后序相同，说明没有左右孩子，则为空树或者单节点
*  前序中序相同，说明缺失左
*  中序后序相同，说明缺失右

（2）给中序和前/后序还原二叉树，给层次遍历和前中后序还原二叉树

（3）画出二叉树对应的森林

（4）给出缺省的前中后序，补全缺失节点

（5）给树的两个序遍历，还原树（前序和后序也可以）

（6）利用二叉树转化表达式

找到表达式中最后使用的操作符，作为二叉树根节点，左侧右侧递归生成的二叉树分别为左孩子和右孩子

（7）平均查找长度ASL=Σ层数*这一层的节点数/节点总数（等概率情况下）

### 4.4 线索二叉树*（貌似不考）

（1）n个节点的二叉树有2n个指针，n-1个孩子指针，n+1个线索指针

### 4.5 森林

#### 4.5.1树、森林转化成二叉树的方法

![image-20191229190626235](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229190626235.png)

![image-20191229190648267](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229190648267.png)

![image-20191229190705796](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229190705796.png)

![image-20191229191653157](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229191653157.png)

高为H的满二叉树能转化成H课树，完全二叉树不一定

#### 4.5.2 遍历

树的先根、后根遍历对应二叉树的前序、中序遍历

#### 4.5.3 表示方法及参数

### 4.6 Huffman树

Huffman树是叶节点带权路径长度最短的二叉树

（1）建立Huffman树

（2）计算带权路径长度

（3）求字符的Huffman编码 

（4）判断字符的Huffman编码是否正确：如果有度为1 的节点则错误

（5）在合并多个有序表中的应用

（6）给定一串01串，还原Huffman树

（7）n个叶子节点则有2n-1个节点

## 五、图

### 5.1 概念

#### 5.1.1 基本概念

* 图：有限集V和E的有序对，G=（V,E）

* 顶点：V的元素，也叫节点或者点

* 边：E的元素，也叫弧或者线  可以用元组（i,j）表示，i和j是边连接的两个顶点

* 有向边：有方向，带箭头

* 无向边：无方向，无箭头 。无向图的边数在0-n(n-1)/2之间

* 邻接、关联：存在边连接顶点i和j，称两个顶点邻接，边（i，j）关联于顶点i,j  在有向图中还可说关联于（from），关联至（to）,邻接于，邻接至

* 无向图、有向图：所有边为无向边则为无向图，所有边为有向边则为有向图

* 自连边：两个顶点之间不止一条边，也叫环

* 权：边的长度

* 网络：加权图

* 路径：顶点序列

* 简单路径：除第一个和最后一个顶点以外其余所有顶点都不同的路径

* 路径长度：该路径所有边长度之和

* 子图：H的顶点和边的集合分别是G的顶点和边的集合的子集，称H为G的子图 若边子集某条边的两个顶点不在顶点集子集中，则不可以构成图

* 环路：起点终点相同的简单路径，也叫简单回路

* 回路：一般有专指[有向图](https://www.baidu.com/s?wd=有向图&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，从某点出发，最终又有边回到该点，注意一个边出一个边入，如果某点只有输出或输入，那该点就没有回路。

* 树：无环路的连通无向图

* 生成树：G的子图包含G的所有顶点且是一棵树

* 度：在无向图中与某顶点相关联的边数。   无向图顶点度之和为边数2倍

* 完全图：边数为n(n-1)/2,顶点数为n的无向图

* 入度，出度：有向图关联至（to）某顶点的边数和关联于（from）某顶点的边数 有向图顶点入度之和和出度之和都为边数，且有向图边数在0-n(n-1)之间

* 连通图：如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。

* [连通分量](https://baike.baidu.com/item/连通分量)：[无向图](https://baike.baidu.com/item/无向图) *G*的一个极大连通子图称为 *G*的一个连通分量（或[连通分支](https://baike.baidu.com/item/连通分支)）。连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量，最多有n/2（向下取整）个。

  **一个[无向图](https://baike.baidu.com/item/无向图) *G*=(*V*,*E*) 是连通的，那么边的数目大于等于[顶点](https://baike.baidu.com/item/顶点)的数目减一：|E|>=|V|-1，而反之不成立。**** 

  **如果 *G*=(*V*,*E*) 是[有向图](https://baike.baidu.com/item/有向图)，那么它是[强连通图](https://baike.baidu.com/item/强连通图)的必要条件是边的数目大于等于顶点的数目：|E|>=|V|，而反之不成立。**

  **没有回路的无向图是连通的当且仅当它是树，即等价于：|E|=|V|-1。**

  保证无向图连通的充分条件：有C（2，n-1）+1条边

  ​                               必要条件：有n-1条边

  5.1.2 连通分量和强联通分量求法

  

* [连通分量](https://baike.baidu.com/item/连通分量)：[无向图](https://baike.baidu.com/item/无向图) *G*的一个极大连通子图称为 *G*的一个连通分量（或[连通分支](https://baike.baidu.com/item/连通分支)）。连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量。

#### 5.1.2 连通分量

####  连通分量的求解方法 

对于一个无向图的连通分量，从连通分量的任意一个顶点开始，进行一次DFS，一定能遍历这个连通分量的所有顶点。所以，整个图的连通分量数应该等价于遍历整个图进行了几次（最外层的）DFS。一次DFS中遍历的所有顶点属于同一个连通分量。

**强连通分量的求解方法** 

求解强连通分量的步骤可以分为两步：

（1）对原图取反，从任意一个顶点开始对反向图进行逆后续DFS遍历

（2）按照逆后续遍历中栈中的顶点出栈顺序，对原图进行DFS遍历，一次DFS遍历中访问的所有顶点都属于同一强连通分量。

![image-20191229213553075](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229213553075.png)

![image-20191229213611223](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229213611223.png)

![image-20191229213627221](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191229213627221.png)

 

### 5.2 存储方式

#### 5.2.1 邻接矩阵

* 注意无向图的对称性，不要忘记÷2
* 入度对应一行，出度对应一列，边数对应非0元素数
* 空间消耗只与顶点数有关

#### 5.2.2 邻接表

* 空间消耗与顶点数、边数都有关 
* 概念：顶点表，边表，表节点
* 表节点个数为边的2倍

#### 5.2.3 邻接矩阵与邻接表的比较、相互转化

判断两个顶点是否有边相连，邻接矩阵方便

查找任意顶点的第一个/下一个邻接点，邻接表方便

#### 5.2.4 稀疏矩阵的一般压缩方法

三元组表

![口袋扫描仪 2019-12-31 17.02.34 0](C:\Users\肖中遥\Documents\Tencent Files\1624604037\FileRecv\MobileFile\口袋扫描仪 2019-12-31 17.02.34 0.jpg)

十字链表

![image-20191231170541728](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191231170541728.png)

### 5.3 深度优先遍历（DFS）

#### 5.3.1 时间复杂度

对邻接矩阵：O（n²）

对邻接表：O（n+e）

#### 5.3.2 根据邻接表/矩阵写出DFS得到的序列

#### 5.3.3 应用

判断图中是否有环：拓扑排序或DFS

画深度优先生成树

### 5.4 广度优先遍历（BFS）

#### 5.4.1 与DFS比较

生成的树高≤DFS生成的

时间复杂度一致

#### 5.4.2 应用

求无向图的所有连通分量

#### 5.4.3 实现

队列，每个节点最多进队一次

画广度优先生成树

### 5.5 最小生成树

#### 5.5.1 概念

* 生成树：连通图的极小连通子图
  * 不唯一
  * 边数为n-1
  * 环的生成树有2n棵

* 最小生成树：所有生成树中权值之和最小的生成树

#### 5.5.2 Kruskal算法

适用于边稀疏的图 时间复杂度O（elog2e）

步骤：此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 
 \1. 把图中的所有边按代价从小到大排序； 
 \2. 把图中的n个顶点看成独立的n棵树组成的森林； 
 \3. 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 
 \4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

![img](https://img-blog.csdn.net/20160714144315409)

#### 5.5.3 Prim算法

适用于边稠密的图 时间复杂度O（n²）

步骤：此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。

 

1. 图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;
2. 在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。
3. 重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。

由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息，

![img](https://img-blog.csdn.net/20160714161107576)

### 5.6 最短路径

#### 5.6.1 单源最短路径——Dijkstra算法

复杂度O（n²）

#### 5.6.2 所有成对顶点最短路径——Floyd算法

复杂度O（n³）

不允许包含带负权值的边组成的回路

```c++
 for(k=1;k<=n;k++)  
 	for(i=1;i<=n;i++)  
    	for(j=1;j<=n;j++)  
         if(e[i][j]>e[i][k]+e[k][j])  
         	e[i][j]=e[i][k]+e[k][j];  
```

### 5.7 拓扑排序

#### 5.7.1 概念

有向无环图（Directed Acyclic Graph, DAG）是有向图的一种，字面意思的理解就是图中没有环。常常被用来表示事件之间的驱动依赖关系，管理任务之间的调度。拓扑排序是对DAG的顶点进行排序，使得对每一条有向边(u, v)，均有u（在排序记录中）比v先出现。亦可理解为对某点v而言，只有当v的所有源点均出现了，v才能出现。

时间复杂度O（n+e)

不唯一

可以拓扑排序的其邻接矩阵·为三角矩阵

#### 5.7.2 入度表实现

对于DAG的拓扑排序，显而易见的办法：

- 找出图中0入度的顶点；
- 依次在图中删除这些顶点，删除后再找出0入度的顶点；
- 然后再删除……再找出……
- 直至删除所有顶点，即完成拓扑排序

#### 5.7.3 DFS实现

在DFS中，依次打印所遍历到的顶点。在DFS实现拓扑排序时，用**栈**来保存拓扑排序的顶点序列；并且保证在某顶点入栈前，其所有邻接点已入栈。

### 5.8 关键路径

#### 5.8.1 最早、最迟开始时间

事件的最早发生时间：ve[k]

根据AOE网的性质，只有进入Vk的所有活动<Vj, Vk>都结束，Vk代表的事件才能发生，而活动<Vj, Vk>的最早结束时间为ve[j]+len<Vj, Vk>。所以，计算Vk的最早发生时间的方法为：

ve[0] = 0

ve[k] = max(ve[j] + len<Vj, Vk>)

事件的最迟发生时间：vl[k]

vl[k]是指在不推迟整个工期的前提下，事件Vk允许的最迟发生时间。根据AOE网的性质，只有顶点Vk代表的事件发生，从Vk出发的活动<Vk, Vj>才能开始，而活动<Vk, Vj>的最晚开始时间为vl[j] - len<Vk, Vj>。

活动的最早发生时间：ee[i]

ai由有向边<Vk, Vj>，根据AOE网的性质，只有顶点Vk代表的事件发生，活动ai才能开始，即活动ai的最早开始时间等于事件Vk的最早开始时间。

活动的最迟发生时间：el[i]

el[i]是指在不推迟真个工期的前提下，活动ai必须开始的最晚时间。若活动ai由有向边<Vk, Vj>表示，则ai的最晚开始时间要保证事件vj的最迟发生时间不拖后。

#### 5.8.2 例子



![20190402090554588](C:\Users\肖中遥\Desktop\20190402090554588.png)

事件的最早发生时间：ve[k]

从源点向终点方向计算

ve[0] = 0

ve[1] = ve[0] + a0 = 0 + 4 = 4

ve[2] = max( ve[0] + a1, ve[1] + a2 ) = max(0 + 3, 4 + 2 = 6

ve[3] = max(ve[1] + a4, ve[2] + a3) = max(4 + 6, 3 + 4) = 10

事件的最迟发生时间：vl[k]

从终点向源点方向计算

vl[3] = ve[3] = 10

vl[2] = vl[3] - a3 = 10 - 4 = 6

vl[1] = min(vl[3] - a4, vl[2] - a2) = min(10-6, 6-2) = 4

vl[0] = min(vl[2] - a1, vl[1] - a0) = min(4-4, 4-2) = 0 

活动的最早发生时间：ee[i]

共有五个活动：

ee[0] = ve[0] = 0

ee[1] = ve[0] = 0

ee[2] = ve[1] = 4

ee[3] = ve[2] = 6

ee[4] = ve[1] = 4

活动的最迟发生时间：el[i]

el[0] = v[1] - a0 = 4 - 4 = 0

el[1] = vl[2] - a1 = 6 - 3 = 3

el[2] = vl[2] - a2 = 6 - 2 = 4

el[3] = vl[3] - a3 = 10 - 4 = 6

el[4] = vl[3] - a4 = 10 - 6 = 4

 

活动的最早开始时间和最晚开始时间相等，则说明该活动时属于关键路径上的活动，即关键活动。
经过比较，得出关键活动有：a0, a2, a3, a4，画出示意图如下

![image-20191231203113402](C:\Users\肖中遥\AppData\Roaming\Typora\typora-user-images\image-20191231203113402.png)

该AOE网有两条关键路径。

 所以，通过此案例也可以发现，一个AOE网的关键路径可能有多条。

**总结**

 　求关键路径，只需理解顶点（事件）和边（活动）各自的两个特征属性以及求法即可：

 　　Ø 先根据首结点的Ve(j)=0**由前向后**计算各顶点的最早发生时间

 　　Ø 再根据终结点的Vl(j)等于它的Ve(j)**由后向前**依次求解各顶点的最晚发生时间

 　　Ø 根据边的e(i)等于它的发出顶点的Ve(j)计算各边的最早开始时间（最早开始，对应最早发生）

 　　Ø 根据边的l(i)等于它的到达顶点的Vl(j)减去边的权值计算各边的最晚开始时间（最晚开始，对应最晚发生）

## 六、查找

### 6.1 顺序查找

成功的平均查找长度（n+1）/2

不成功平均查找长度 n

堆的顺序查找复杂度O（n）

### 6.2 二分查找

#### 6.2.1 方法、查找次数

若当前元素个数为奇数，查找中间元素；元素个数为偶数，查找中间靠前元素

若不存在，看判定树高度，不小于log2(n+1)的最小整数；若存在，ASL计算

会求查找长度为m的关键码3个数

#### 6.2.2 适用范围

有序顺序表

#### 6.2.3 实现（递归与非递归）

#### 6.2.4 判定树

判定树是平衡树

会画判定树

树高为【log2n】

### 6.3 BST、AVL

n个节点最大查找次数是n，考虑特殊情况 

高为H的AVL最多节点个数2^h-1 最少递归求f(h)=f(h-1)+f(h-2)+1 f(1)=1 f(2)=2

### 6.4 B-Tree

求高为n的m阶B树最多/最少包含多少个关键字7

### 6.5 RBT

### 6.6 Hash

查找成功的平均查找长度与装填因子有关

处理冲突：链地址法

线性探测再散列法

## 七、排序

### 7.1 插入排序与希尔排序

二分法插入排序比较次数与初始状态无关，且稳定

直接插入不稳定

区别在于元素比较次数

直接插入若干趟后，前几个有序

只有插入排序才会使最后一趟开始之前所有元素不在其最终位置上、

插入和希尔每趟过后未必能确定一个元素的最终位置

希尔插入若干趟后，有有序子序列

### 7.2 冒泡排序与选择排序

冒泡稳定

每趟过后都能确定一个元素的最终位置（选出一个最大的或最小的放到其最终位置）

### 7.3 快速排序

不稳定

每趟过后都会使原序列的第一个元素放到其最终位置

初始有序反而最费时

数据完全无序最有利

### 7.4 归并排序

稳定

### 7.5 堆排序

不稳定

每趟过后都能确定一个元素的最终位置（选出一个最大的或最小的放到其最终位置）

### 7.6 基数排序

稳定

### 7.7 *桶排序与计数排序



